import { Router, Request, Response } from 'express';
import { AmpFormSubmission, FormStructure, FormField, SubmissionMetadata } from '../types';
import { database } from '../services/database';
import { logger, logHelpers } from '../utils/logger';
import { 
  validateAmpSignature, 
  parseAmpFormData, 
  handleDoNotTrack, 
  logRequest 
} from '../middleware/ampValidation';

const router = Router();

/**
 * Main webhook endpoint for AMP form submissions
 * Handles any form structure dynamically
 */
router.post('/webhook', 
  logRequest,
  handleDoNotTrack,
  parseAmpFormData,
  validateAmpSignature,
  async (req: Request, res: Response) => {
    const startTime = Date.now();
    
    try {
      // Extract form data from request body
      const formData = req.body || {};
      const isTracked = (req as any).isTracked !== false;
      
      // Analyze form structure dynamically
      const formStructure = analyzeFormStructure(formData, req);
      
      // Extract metadata
      const metadata: SubmissionMetadata = {
        userAgent: req.get('User-Agent') || 'Unknown',
        ipAddress: req.ip,
        referer: req.get('Referer'),
        ampTimestamp: req.get('amp-ts'),
        ampSignature: req.get('amp-signature'),
        ampSignatureValid: req.ampData?.isValidSignature || false,
        formStructure
      };
      
      // Create submission object
      const submission: AmpFormSubmission = {
        id: '', // Will be generated by database
        formId: formStructure.formId,
        formData,
        metadata,
        timestamp: new Date(),
        isTracked,
        isAmpValidated: req.ampData?.isValidSignature || false
      };
      
      // Log the submission
      logHelpers.logSubmission({
        formData,
        metadata,
        isTracked,
        validationResult: { isValid: metadata.ampSignatureValid || false }
      });
      
      // Save to database if tracking is enabled
      let submissionId: string | null = null;
      if (isTracked) {
        try {
          submissionId = await database.saveSubmission(submission);
          logger.info('Form submission saved successfully', {
            submissionId,
            formId: formStructure.formId
          });
        } catch (dbError: any) {
          logger.error('Failed to save submission to database', {
            error: dbError?.message || 'Unknown error',
            formData: formData
          });
          // Continue processing even if database save fails
        }
      } else {
        logger.info('Form submission not tracked due to doNotTrackThis parameter');
      }
      
      // Log performance
      const processingTime = Date.now() - startTime;
      logHelpers.logPerformance('webhook_processing', processingTime, {
        formId: formStructure.formId,
        fieldCount: Object.keys(formData).length,
        saved: !!submissionId
      });
      
      // Return success response with AMP-compatible format
      const response = {
        success: true,
        message: 'Form submission received successfully',
        submissionId: submissionId,
        timestamp: new Date().toISOString(),
        formId: formStructure.formId,
        tracked: isTracked
      };
      
      // Set appropriate headers for AMP
      res.set({
        'Content-Type': 'application/json',
        'Access-Control-Allow-Credentials': 'true',
        'AMP-Access-Control-Allow-Source-Origin': req.headers.origin || '*'
      });
      
      res.status(200).json(response);
      
    } catch (error: any) {
      const processingTime = Date.now() - startTime;
      
      logger.error('Webhook processing error', {
        error: error?.message || 'Unknown error',
        stack: error?.stack,
        body: req.body,
        headers: req.headers,
        processingTime
      });
      
      // Return error response
      res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: 'Failed to process form submission',
        timestamp: new Date().toISOString()
      });
    }
  }
);

/**
 * Health check endpoint
 */
router.get('/health', (req: Request, res: Response) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version || '1.0.0'
  });
});

/**
 * Get webhook statistics (public endpoint)
 */
router.get('/stats', async (req: Request, res: Response) => {
  try {
    const stats = await database.getAdminStats();
    
    // Return public stats only
    res.json({
      totalSubmissions: stats.totalSubmissions,
      formTypes: stats.formTypes.map(ft => ({ formId: ft.formId, count: ft.count })),
      lastUpdated: new Date().toISOString()
    });
  } catch (error: any) {
    logger.error('Failed to get webhook stats', { error: error?.message || 'Unknown error' });
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve statistics'
    });
  }
});

/**
 * Test endpoint for development
 */
router.post('/test', (req: Request, res: Response) => {
  logger.info('Test endpoint called', {
    body: req.body,
    headers: req.headers,
    query: req.query
  });
  
  res.json({
    success: true,
    message: 'Test endpoint working',
    received: {
      body: req.body,
      query: req.query,
      headers: {
        'content-type': req.headers['content-type'],
        'user-agent': req.headers['user-agent'],
        'amp-signature': req.headers['amp-signature'],
        'amp-timestamp': req.headers['amp-timestamp']
      }
    },
    timestamp: new Date().toISOString()
  });
});

/**
 * Analyze form structure dynamically
 */
function analyzeFormStructure(formData: any, req: Request): FormStructure {
  const fields: FormField[] = [];
  
  // Analyze each field in the form data
  Object.entries(formData).forEach(([key, value]) => {
    const field: FormField = {
      name: key,
      type: inferFieldType(value),
      value: String(value),
      required: false // Can't determine from submission data
    };
    fields.push(field);
  });
  
  // Try to determine form ID from various sources
  let formId = 'unknown';
  
  // Check for common form identifiers
  if (formData.formId) {
    formId = formData.formId;
  } else if (formData.form_id) {
    formId = formData.form_id;
  } else if (formData.choice) {
    // For the user's poll forms
    formId = `poll_${formData.choice}`;
  } else if (req.headers.referer) {
    // Extract from referer if available
    const refererUrl = new URL(req.headers.referer);
    formId = `form_${refererUrl.pathname.replace(/[^a-zA-Z0-9]/g, '_')}`;
  } else {
    // Generate based on field structure
    const fieldNames = Object.keys(formData).sort().join('_');
    formId = `form_${fieldNames.substring(0, 50)}`;
  }
  
  return {
    formId,
    fields,
    method: 'POST',
    action: req.url
  };
}

/**
 * Infer field type from value
 */
function inferFieldType(value: any): string {
  if (typeof value === 'boolean') return 'checkbox';
  if (typeof value === 'number') return 'number';
  if (typeof value === 'string') {
    if (value.includes('@')) return 'email';
    if (value.match(/^\d{4}-\d{2}-\d{2}$/)) return 'date';
    if (value.match(/^\d+$/)) return 'number';
    if (value.length > 100) return 'textarea';
    return 'text';
  }
  return 'text';
}

export default router;